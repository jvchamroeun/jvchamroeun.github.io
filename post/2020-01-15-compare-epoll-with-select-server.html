<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Compare Epoll with Select server</title>
        <link rel="icon" type="image/x-icon" href="assets/logo.png" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="../css/styles.css" rel="stylesheet" />
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
            <div class="container">
                <img src="../assets/logo.png" width="50" height="50" />
                <a class="navbar-brand" href="../index.html">Eric Wu</a>
                <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ml-auto">
                        <li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
                        <li class="nav-item"><a class="nav-link" href="../about.html">About</a></li>
                        <li class="nav-item"><a class="nav-link" href="../project.html">Projects</a></li>
                        <li class="nav-item"><a class="nav-link" href="../contact.html">Contact</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Header-->
        <header class="masthead" style="background-image: url('../assets/img/compare-epoll-with-select-server/banner.jpg')">
            <div class="overlay"></div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <div class="post-heading">
                            <h1>Compare Epoll with Select server</h1>
                            <h2 class="subheading">compare the scalability and performance of the select and epoll-based client server implementations</h2>
                            <span class="meta">
                                Posted by
                                <a href="#!">Eric Wu</a>
                                on January 15, 2020
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!-- Post Content-->
        <article>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <h2 class="section-heading">Objective</h2>
                        <p>To compare the scalability and performance of the select and epoll-based client server implementations.</p>
                        <h2 class="section-heading">Approach</h2>
                        <p>The client server implementation will be a simple echo-reply server. The main functionality of the client is to send the server with a message, and read the reply from the server, the process will continue several times. As for the servers, the main functionality is to process the client's echo request and reply back with the same echo message. Two versions of server are implemented - an ​ epoll ​ version and a ​ select ​ version. Both versions will have similar architecture in terms of implementation.</p>
                        <p>Each client will also maintain a record of how many requests it made to the server, the amount of data sent to the server, and the amount of time it took for the server to respond. The server will maintain a list of all connected clients (host names) and store the list together with the number of requests generated by each client and the amount of data transferred to each client.</p>
                        <p>The figure below shows an overview of the workflow</p>
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/overview.jpg" alt="..." />
                        <h2 class="section-heading">Source code</h2>
                        <p>
                            The project source code can be found
                            <a href="https://github.com/ericwu1997/compare-epoll-with-select" style="color: blue">here</a>
                            .
                        </p>
                        <h2 class="section-heading">State Diagram</h2>
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/state-machine-1.jpg" alt="..." />
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/state-machine-2.jpg" alt="..." />
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/state-machine-3.jpg" alt="..." />
                        <h2 class="section-heading">Usage</h2>
                        <pre>
Name 
      client.c
Option
      -h (--host)     hostname
      -p (--port)     server listening port
      -m (--message)  echo message
      -c (--count)    number of echo request to send
      -d (--delay)    delay between request (nsec, max 1 sec)
</pre
                        >
                        <hr />
                        <pre>
Name
      server.c (select)
Option
      -p (--p)    listening port</pre
                        >
                        <hr />
                        <pre>
Name
      server.c (epoll)
Option
      -p (--port)     listening port
      -m (--max-core) number of worker thread to scale accept</pre
                        >
                        <h2 class="section-heading">How to run</h2>
                        <p>
                            Client
                            <br />
                            On the client machine, cd to the “client” folder. Fill in the server info in the Makefile, and run
                            <br />
                            <strong>$ make all</strong>
                            <br />
                            If the server is running, the client should display some results in console.
                        </p>
                        <p>
                            Server (select)
                            <br />
                            On the server machine, cd to the “select” folder, Fill the value for the macro “PORT” in the Makefile, and run
                            <br />
                            <strong>$ make all</strong>
                            <br />
                            The console should display message indicating server is running
                        </p>
                        <p>
                            Server (epoll)
                            <br />
                            On the server machine, cd to the “epoll” folder, Fill the value for the macro “PORT” and “MAX_CORES” in the Makefile, and run
                            <br />
                            <strong>$ make all</strong>
                            <br />
                            The console should display message indicating server is running
                        </p>
                        <h2 class="section-heading">Testing</h2>
                        <p>The idea is to keep adding workload to the server until the server shows a significant degradation in performance. We will increase the workload by adding more clients, more sent requests and bigger echo messages. At the end of the testing (both ​ epoll ​ and ​ select server), the result of each of the test cases will be grouped together,and plotted into a line graph.</p>
                        <p>The Makefiles in each of the “select” and “epoll” folder contains both test scripts test-a and test-b.</p>
                        <p>
                            <strong>Test Script</strong>
                            <br />
                            <strong>test-a</strong>
                            <br />
                            Spawns a fixed number of clients per interval for a fixed number of times. The client spawn from this test will send string data to the server periodically.
                            <strong>test-b</strong>
                            <br />
                            Keep on adding clients per interval indefinitely. The client spawn from this test will send string data to the server periodically.
                        </p>
                        <p>
                            The command for running the test is
                            <strong>$make test-a</strong>
                            ​ and
                            <strong>$make test-b</strong>
                        </p>
                        <p>
                            <strong>Case 1</strong>
                            <br />
                            In this case, we try to determine the maximum active socket the server can handle in one session. We use the ​ test-b ​ test script to keep adding clients indefinitely until there’s a significant degradation in performance on the server side. Each spawn client will send an echo request to the server and wait for a reply, this process will continue for enough time until the performance on server side drop.
                        </p>
                        <p><strong>Testing params</strong></p>
                        <ul>
                            <li>20000 echo request (10000 each on two client machines)</li>
                            <li>10000 nsec delay in between each echo request (not including the response time from previous request)</li>
                            <li>0.002 sec client spawn delay</li>
                        </ul>
                        <p>
                            <strong>Monitoring tool</strong>
                            : Wireshark
                        </p>
                        <p>
                            <strong>select server statistic</strong>
                            <br />
                            The hard limit for the select() server is 1024, so we will not test it. The number is confirmed by looking at the source code for the ​ FD_SET ​ type, which consists of an integer list of size 32. (one bit represents one socket, i.e there's 32*16 = ​
                            <strong>1024</strong>
                            ​ socket max)
                        </p>
                        <p>
                            <strong>epoll server statistic</strong>
                            <br />
                        </p>
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/test-1.jpg" alt="..." />
                        <p>
                            <strong>Case 2</strong>
                            <br />
                            In this case, we are testing the server performance when requests are sent infrequently during an active connection. We use ​ test-a ​ to spawn a fixed number of clients, and keep all the connections active for around 3 minutes.
                        </p>
                        <p><strong>Testing params</strong></p>
                        <ul>
                            <li>6 spawn cycle, 256 spawn per cycle = 1024 clients in total</li>
                            <li>0.02 sec client spawn delay</li>
                            <li>100000 request per client (will not process all if 3 minutes hit)</li>
                            <li>10 msec delay between each request (not including response time from previous request)</li>
                        </ul>
                        <p>
                            <strong>Monitoring tool</strong>
                            : Wireshark
                        </p>
                        <p>
                            <strong>Results</strong>
                            <br />
                        </p>
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/test-2.jpg" alt="..." />
                        <p>
                            <strong>Case 3</strong>
                            <br />
                            In this case, we are testing the server performance when requests are sent frequently during an active connection. We use ​ test-a ​ to spawn a fixed number of clients, and keep all the connections active for around 10 sec.
                        </p>
                        <p><strong>Testing params</strong></p>
                        <ul>
                            <li>1 spawn cycle, 256 spawn per cycle = 256 clients in total</li>
                            <li>0.02 sec client spawn delay</li>
                            <li>100000 request per client (will not process all if 3 minutes hit)</li>
                            <li>0.1 msec delay between each request (not including response time from previous request)</li>
                        </ul>
                        <p>
                            <strong>Monitoring tool</strong>
                            : Wireshark
                        </p>
                        <p>
                            <strong>Results</strong>
                            <br />
                        </p>
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/test-3.jpg" alt="..." />
                        <p>
                            <strong>Case 4</strong>
                            <br />
                            In this case, we are testing the server response performance when there's short live, intense traffic coming in. We use ​ test-b ​ to spawn clients indefinitely. Each client will keep the connection alive until they receive all pending replies from the server.
                        </p>
                        <p><strong>Testing params</strong></p>
                        <ul>
                            <li>Keep spawning clients until 300 spawn</li>
                            <li>0.01 sec client spawn delay</li>
                            <li>1 request per client</li>
                            <li>1 msec delay between each request (not including response time from previous request)</li>
                        </ul>
                        <p>
                            <strong>Monitoring tool</strong>
                            : response time record kept on client side
                        </p>
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/test-4.jpg" alt="..." />
                        <p>
                            <strong>Case 5</strong>
                            <br />
                            In this case, we are testing the server response performance when there's short live, intense traffic coming in. We use ​ test-b ​ to spawn clients indefinitely. Each client will keep the connection alive until they receive ​ one​ reply from the server.
                        </p>
                        <p><strong>Testing params</strong></p>
                        <ul>
                            <li>Keep spawning clients until 300 spawn</li>
                            <li>0.01 sec client spawn delay</li>
                            <li>1000 request per client</li>
                            <li>1 msec delay between each request (not including response time from previous request)</li>
                        </ul>
                        <p>
                            <strong>Monitoring tool</strong>
                            : response time record kept on client side
                        </p>
                        <img class="img-fluid" src="../assets/img/compare-epoll-with-select-server/test-5.jpg" alt="..." />
                        <h2 class="section-heading">Analysis</h2>
                        <p>
                            <strong>Case 1</strong>
                            <br />
                            The hard limit on the select server is ​ 1024 ​ active sockets in one session. As for the epoll server, according to the wireshark conversation, we recorded a total of roughly 20000 active socket connections in one session. We could have kept the test longer, and the number will go higher. However, the wireshark IO graph on the epoll server shows that the number of incoming packets dropped when the active socket count hits ​ 20000 ​ mark. The drop happened because the server was not able to reply back to the client as quickly as before, i.e the response time increased. The client will only send one request when the previous request is answered.
                        </p>
                        <p>
                            <strong>Case 2</strong>
                            <br />
                            The condition we made for this case is that data is sent infrequently while the connection is alive. The IO graph on select server shows an average of 6500 packets/s. As for the epoll server, the IO graph shows an average of roughly 6000 packets/s. One thing to note is that the incoming requests for the select server are comparably consistent than the epoll server. This indicates that the selected server has a fairly consistent response rate. The epoll server has a more inconsistent response rate
                        </p>
                        <p>
                            <strong>Case 3</strong>
                            <br />
                            The condition we made for this case is that data is sent more frequently than case 2, while the connection is alive. The IO graph on select server shows an average of 115000 packets/s. As for the epoll server, the IO graph shows an average of roughly 109000 packets/s. As we can see, the performance gap between select and epoll close in as the frequency of request increases.
                        </p>
                        <p>
                            <strong>Case 4</strong>
                            <br />
                            The condition we made for this case is that connections are short live. The response time for the select server is roughly 9 sec in total (average of 0.009 sec per request), the epoll is roughly 15 sec (average of 0.015 sec per request). We will compare this data with the result
                        </p>
                        <p>
                            <strong>Case 5</strong>
                            <br />
                            The condition we made for this case is the same as case 4, except that this time the client will close the connection after receiving one only (even more short live than connections in case 4). The result shows that the response time for the select server is roughly 0.673 millisecond, the epoll server has a response time of roughly 0.403 millisecond. This time the epoll server seems to have a better performance than the select server.
                        </p>
                        <h2 class="section-heading">Explain</h2>
                        <p>The select server uses level trigger, while the epoll server uses edge trigger. The main difference is the event trigger mechanism. Level trigger will keep on notifying the event status on a socket as long as the status is readable (this could occur anywhere in the allocated time splice). Edge triggers will only notify once when the status on a socket changes (only occur during the beginning of time splice).</p>
                        <p>So does that mean epoll is more efficient than select? The test result in test case 2, 3 and 4 says otherwise. The results show that the select server has an overall higher response rate than the epoll server. This is because, each time, if there’s data from a client ready for ready, the select server will loop through all existing clients to see if there's data available. So if a data comes in from another client while the select server is looping through the list, there’s a good chance it will read it as well. In the case of an epoll server, it will only read on the socket that is ready for read, and that socket only.</p>
                        <p>
                            The epoll server has some advantages over the select server as well. In case 1, it's evident to say that epoll can monitor why more sockets than select server. The result shows that select could monitor up to 1024 only, while the epoll can monitor 20000 sockets or more. Moreover, In case 5, the result shows that the epoll server has roughly 60% higher response rate than the select server. This happens because of the edge trigger implementation. To run edge trigger, the socket would have to be unblocking. If there’s a new connection request, the kernel will notify the server program (assuming the epoll_wait was called prior to the new connection). The behavior of epoll_wait requires the program to accept new connections until there’s no new connection in the queue list. If a new connection comes in while the server is accepting a connection, it will pick up the new connection as well. This explains why the epoll server has better performance than select
                            server in case 5.
                        </p>
                        <h2 class="section-heading">Conclusion</h2>
                        <p>Epoll is useful when implementing a server that deals with massive number of short live connections in a short period of time. This is because the server prioritizes accepting new connections.</p>
                        <p>Select is useful when implementing a server that handles moderate amounts, long live connection with frequent request. This is because the server prioritizes reading datas from the client.</p>
                        <p>This conclusion is made based on the fact that either version of server scale out the read or accept operation. It will be difficult to implement scalability in select server because of the level trigger mechanism (wakes up all blocking select calls). This is not the case for epoll because of the default behavior of edge trigger (only wake up one blocking epoll_wait call). So if the epoll scale out the blocking operation, it is possible that the epoll server will yield better performance than select server on all aspects.</p>
                    </div>
                </div>
            </div>
        </article>
        <hr />
        <!-- Footer-->
        <footer>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <ul class="list-inline text-center">
                            <li class="list-inline-item">
                                <a href="https://linkedin.com/in/ericwu1997">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li class="list-inline-item">
                                <a href="https://github.com/ericwu1997">
                                    <span class="fa-stack fa-lg">
                                        <i class="fas fa-circle fa-stack-2x"></i>
                                        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                        </ul>
                        <p class="copyright text-muted">Copyright &copy; Your Website 2021</p>
                    </div>
                </div>
            </div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="../js/scripts.js"></script>
    </body>
</html>
